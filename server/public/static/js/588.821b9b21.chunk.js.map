{"version":3,"file":"static/js/588.821b9b21.chunk.js","mappings":"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","sources":["../node_modules/@graphiql/graphql-language-service/esm/utils/Range.js","../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../node_modules/graphql/language/predicates.mjs","../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../node_modules/graphql/validation/specifiedRules.mjs","../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs","../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../node_modules/graphql/validation/ValidationContext.mjs","../node_modules/graphql/validation/validate.mjs","../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../node_modules/@graphiql/graphql-language-service/esm/utils/validateWithCustomRules.js","../node_modules/@graphiql/graphql-language-service/esm/interface/getDiagnostics.js","../node_modules/@graphiql/codemirror-graphql/esm/lint.js"],"sourcesContent":["export class Range {\n    constructor(start, end) {\n        this.containsPosition = (position) => {\n            if (this.start.line === position.line) {\n                return this.start.character <= position.character;\n            }\n            if (this.end.line === position.line) {\n                return this.end.character >= position.character;\n            }\n            return this.start.line <= position.line && this.end.line >= position.line;\n        };\n        this.start = start;\n        this.end = end;\n    }\n    setStart(line, character) {\n        this.start = new Position(line, character);\n    }\n    setEnd(line, character) {\n        this.end = new Position(line, character);\n    }\n}\nexport class Position {\n    constructor(line, character) {\n        this.lessThanOrEqualTo = (position) => this.line < position.line ||\n            (this.line === position.line && this.character <= position.character);\n        this.line = line;\n        this.character = character;\n    }\n    setLine(line) {\n        this.line = line;\n    }\n    setCharacter(character) {\n        this.character = character;\n    }\n}\nexport function offsetToPosition(text, loc) {\n    const EOL = '\\n';\n    const buf = text.slice(0, loc);\n    const lines = buf.split(EOL).length - 1;\n    const lastLineIndex = buf.lastIndexOf(EOL);\n    return new Position(lines, loc - lastLineIndex - 1);\n}\nexport function locToRange(text, loc) {\n    const start = offsetToPosition(text, loc.start);\n    const end = offsetToPosition(text, loc.end);\n    return new Range(start, end);\n}\n//# sourceMappingURL=Range.js.map","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  var oldSchema = context.getSchema();\n  var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();\n  var schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition: function SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new GraphQLError('Cannot define a new schema within a schema extension.', node));\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new GraphQLError('Must provide only one schema definition.', node));\n      }\n\n      ++schemaDefinitionsCount;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  var schema = context.getSchema();\n  var definedOperationTypes = Object.create(null);\n  var existingOperationTypes = schema ? {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  } : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {\n      var operationType = operationTypesNodes[_i2];\n      var operation = operationType.operation;\n      var alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(new GraphQLError(\"Type for \".concat(operation, \" already defined in the schema. It cannot be redefined.\"), operationType));\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(new GraphQLError(\"There can be only one \".concat(operation, \" type in schema.\"), [alreadyDefinedOperationType, operationType]));\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  var knownTypeNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n\n  function checkTypeName(node) {\n    var typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(new GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also be defined in this type definition.\"), node.name));\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(new GraphQLError(\"There can be only one type named \\\"\".concat(typeName, \"\\\".\"), [knownTypeNames[typeName], node.name]));\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isEnumType } from \"../../type/definition.mjs\";\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    var typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n    var valueNames = knownValueNames[typeName];\n\n    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {\n      var valueDef = valueNodes[_i2];\n      var valueName = valueDef.name.value;\n      var existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), valueDef.name));\n      } else if (valueNames[valueName]) {\n        context.reportError(new GraphQLError(\"Enum value \\\"\".concat(typeName, \".\").concat(valueName, \"\\\" can only be defined once.\"), [valueNames[valueName], valueDef.name]));\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  var knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    var typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    var fieldNames = knownFieldNames[typeName];\n\n    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {\n      var fieldDef = fieldNodes[_i2];\n      var fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" already exists in the schema. It cannot also be defined in this type extension.\"), fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(typeName, \".\").concat(fieldName, \"\\\" can only be defined once.\"), [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  var knownDirectiveNames = Object.create(null);\n  var schema = context.getSchema();\n  return {\n    DirectiveDefinition: function DirectiveDefinition(node) {\n      var directiveName = node.name.value;\n\n      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" already exists in the schema. It cannot be redefined.\"), node.name));\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(new GraphQLError(\"There can be only one directive named \\\"@\".concat(directiveName, \"\\\".\"), [knownDirectiveNames[directiveName], node.name]));\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import { Kind } from \"./kinds.mjs\";\nexport function isDefinitionNode(node) {\n  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);\n}\nexport function isExecutableDefinitionNode(node) {\n  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;\n}\nexport function isSelectionNode(node) {\n  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;\n}\nexport function isValueNode(node) {\n  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;\n}\nexport function isTypeNode(node) {\n  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;\n}\nexport function isTypeDefinitionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;\n}\n","import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n","var _defKindToExtKind;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode } from \"../../language/predicates.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType } from \"../../type/definition.mjs\";\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), defNode ? [defNode, node] : node));\n      }\n    } else {\n      var allTypeNames = Object.keys(definedTypes);\n\n      if (schema) {\n        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));\n      }\n\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), node.name));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected kind: ' + inspect(kind));\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport invariant from \"../../jsutils/invariant.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { DirectiveLocation } from \"../../language/directiveLocation.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\nexport function KnownDirectivesRule(context) {\n  var locationsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map(function (name) {\n        return name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(node, _key, _parent, _path, ancestors) {\n      var name = node.name.value;\n      var locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new GraphQLError(\"Unknown directive \\\"@\".concat(name, \"\\\".\"), node));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new GraphQLError(\"Directive \\\"@\".concat(name, \"\\\" may not be used on \").concat(candidateLocation, \".\"), node));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n  !Array.isArray(appliedTo) || invariant(0);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION:\n      {\n        var parentNode = ancestors[ancestors.length - 3];\n        return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;\n      }\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case 'query':\n      return DirectiveLocation.QUERY;\n\n    case 'mutation':\n      return DirectiveLocation.MUTATION;\n\n    case 'subscription':\n      return DirectiveLocation.SUBSCRIPTION;\n  } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n  false || invariant(0, 'Unexpected operation: ' + inspect(operation));\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\nexport function UniqueArgumentNamesRule(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n\n      if (knownArgNames[argName]) {\n        context.reportError(new GraphQLError(\"There can be only one argument named \\\"\".concat(argName, \"\\\".\"), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\nexport function UniqueInputFieldNamesRule(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(new GraphQLError(\"There can be only one input field named \\\"\".concat(fieldName, \"\\\".\"), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isExecutableDefinitionNode } from \"../../language/predicates.mjs\";\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document: function Document(node) {\n      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {\n        var definition = _node$definitions2[_i2];\n\n        if (!isExecutableDefinitionNode(definition)) {\n          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : '\"' + definition.name.value + '\"';\n          context.reportError(new GraphQLError(\"The \".concat(defName, \" definition is not executable.\"), definition));\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new GraphQLError(\"Unknown fragment \\\"\".concat(fragmentName, \"\\\".\"), node.name));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\nexport function NoUnusedFragmentsRule(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {\n          var operation = operationDefs[_i2];\n\n          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {\n            var fragment = _context$getRecursive2[_i4];\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {\n          var fragmentDef = fragmentDefs[_i6];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" is never used.\"), fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\nexport function KnownArgumentNamesRule(context) {\n  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        var suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(parentType.name, \".\").concat(fieldDef.name, \"\\\".\") + didYouMean(suggestions), argNode));\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    directiveArgs[directive.name] = directive.args.map(function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map(function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {\n          var argNode = _directiveNode$argume2[_i6];\n          var argName = argNode.name.value;\n\n          if (knownArgs.indexOf(argName) === -1) {\n            var suggestions = suggestionList(argName, knownArgs);\n            context.reportError(new GraphQLError(\"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\") + didYouMean(suggestions), argNode));\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n","import objectValues from \"../../polyfills/objectValues.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isLeafType, isInputObjectType, isListType, isNonNullType, isRequiredInputField, getNullableType, getNamedType } from \"../../type/definition.mjs\";\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var fieldNodeMap = keyMap(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      for (var _i2 = 0, _objectValues2 = objectValues(type.getFields()); _i2 < _objectValues2.length; _i2++) {\n        var fieldDef = _objectValues2[_i2];\n        var fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          var typeStr = inspect(fieldDef.type);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldDef.name, \"\\\" of required type \\\"\").concat(typeStr, \"\\\" was not provided.\"), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = getNamedType(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new GraphQLError(\"Field \\\"\".concat(node.name.value, \"\\\" is not defined by type \\\"\").concat(parentType.name, \"\\\".\") + didYouMean(suggestions), node));\n      }\n    },\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(inspect(type), \"\\\", found \").concat(print(node), \".\"), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      return isValidValueNode(context, node);\n    },\n    IntValue: function IntValue(node) {\n      return isValidValueNode(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidValueNode(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidValueNode(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidValueNode(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    var typeStr = inspect(locationType);\n    context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if (parseResult === undefined) {\n      var _typeStr = inspect(locationType);\n\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr, \"\\\", found \").concat(print(node), \".\"), node));\n    }\n  } catch (error) {\n    var _typeStr2 = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new GraphQLError(\"Expected value of type \\\"\".concat(_typeStr2, \"\\\", found \").concat(print(node), \"; \") + error.message, node, undefined, undefined, undefined, error));\n    }\n  }\n}\n","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport keyMap from \"../../jsutils/keyMap.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\nimport { isType, isRequiredArgument } from \"../../type/definition.mjs\";\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n        var argNodeMap = keyMap(argNodes, function (arg) {\n          return arg.name.value;\n        });\n\n        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {\n          var argDef = _fieldDef$args2[_i2];\n          var argNode = argNodeMap[argDef.name];\n\n          if (!argNode && isRequiredArgument(argDef)) {\n            var argTypeStr = inspect(argDef.type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {\n    var directive = definedDirectives[_i4];\n    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), function (arg) {\n      return arg.name;\n    });\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {\n    var def = astDefinitions[_i6];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function (arg) {\n        return arg.name.value;\n      });\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n\n          var argNodeMap = keyMap(_argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {\n            var argName = _Object$keys2[_i8];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              var argTypeStr = isType(argType) ? inspect(argType) : print(argType);\n              context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \\\"\").concat(argTypeStr, \"\\\" is required, but it was not provided.\"), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isNonNullType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { isTypeSubTypeOf } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Variables passed to field arguments conform to type\n */\nexport function VariablesInAllowedPositionRule(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var type = _ref2.type;\n          var defaultValue = _ref2.defaultValue;\n          var varName = node.name.value;\n          var varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            var schema = context.getSchema();\n            var varType = typeFromAST(schema, varDef.type);\n\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n              var varTypeStr = inspect(varType);\n              var typeStr = inspect(type);\n              context.reportError(new GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varTypeStr, \"\\\" used in position expecting type \\\"\").concat(typeStr, \"\\\".\"), [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","import find from \"../../polyfills/find.mjs\";\nimport objectEntries from \"../../polyfills/objectEntries.mjs\";\nimport inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { getNamedType, isNonNullType, isLeafType, isObjectType, isListType, isInterfaceType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subReason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \") + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {\n        var _ref3 = conflicts[_i2];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        var reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(\"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMsg, \". Use different aliases on the fields to fetch both if this was intentional.\"), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    var referencedFragmentName = fragmentNames2[i]; // Memoize so two fragments are not compared for conflicts more than once.\n\n    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (var _i5 = 0, _objectEntries2 = objectEntries(fieldMap); _i5 < _objectEntries2.length; _i5++) {\n    var _ref5 = _objectEntries2[_i5];\n    var responseName = _ref5[0];\n    var fields = _ref5[1];\n\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {\n    var responseName = _Object$keys2[_i7];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    var _node1$arguments, _node2$arguments;\n\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\\\"\".concat(name1, \"\\\" and \\\"\").concat(name2, \"\\\" are different fields\")], [node1], [node2]];\n    } // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : []; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : []; // Two field calls must have the same arguments.\n\n    if (!sameArguments(args1, args2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \\\"\".concat(inspect(type1), \"\\\" and \\\"\").concat(inspect(type2), \"\\\"\")], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = find(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return print(value1) === print(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {\n    var selection = _selectionSet$selecti2[_i9];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          var fieldName = selection.name.value;\n          var fieldDef = void 0;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          var responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          var typeCondition = selection.typeCondition;\n          var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref6) {\n      var reason = _ref6[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref7) {\n      var fields1 = _ref7[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref8) {\n      var fields2 = _ref8[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet = /*#__PURE__*/function () {\n  function PairSet() {\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    this._pairSetAdd(a, b, areMutuallyExclusive);\n\n    this._pairSetAdd(b, a, areMutuallyExclusive);\n  };\n\n  _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {\n    var map = this._data[a];\n\n    if (!map) {\n      map = Object.create(null);\n      this._data[a] = map;\n    }\n\n    map[b] = areMutuallyExclusive;\n  };\n\n  return PairSet;\n}();\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from \"./rules/ExecutableDefinitionsRule.mjs\"; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from \"./rules/UniqueOperationNamesRule.mjs\"; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from \"./rules/LoneAnonymousOperationRule.mjs\"; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from \"./rules/SingleFieldSubscriptionsRule.mjs\"; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from \"./rules/KnownTypeNamesRule.mjs\"; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from \"./rules/FragmentsOnCompositeTypesRule.mjs\"; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from \"./rules/VariablesAreInputTypesRule.mjs\"; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from \"./rules/ScalarLeafsRule.mjs\"; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from \"./rules/FieldsOnCorrectTypeRule.mjs\"; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from \"./rules/UniqueFragmentNamesRule.mjs\"; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from \"./rules/KnownFragmentNamesRule.mjs\"; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from \"./rules/NoUnusedFragmentsRule.mjs\"; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from \"./rules/PossibleFragmentSpreadsRule.mjs\"; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from \"./rules/NoFragmentCyclesRule.mjs\"; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from \"./rules/UniqueVariableNamesRule.mjs\"; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from \"./rules/NoUndefinedVariablesRule.mjs\"; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from \"./rules/NoUnusedVariablesRule.mjs\"; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from \"./rules/KnownDirectivesRule.mjs\"; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from \"./rules/UniqueDirectivesPerLocationRule.mjs\"; // Spec Section: \"Argument Names\"\n\nimport { KnownArgumentNamesRule, KnownArgumentNamesOnDirectivesRule } from \"./rules/KnownArgumentNamesRule.mjs\"; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from \"./rules/UniqueArgumentNamesRule.mjs\"; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from \"./rules/ValuesOfCorrectTypeRule.mjs\"; // Spec Section: \"Argument Optionality\"\n\nimport { ProvidedRequiredArgumentsRule, ProvidedRequiredArgumentsOnDirectivesRule } from \"./rules/ProvidedRequiredArgumentsRule.mjs\"; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from \"./rules/VariablesInAllowedPositionRule.mjs\"; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from \"./rules/OverlappingFieldsCanBeMergedRule.mjs\"; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from \"./rules/UniqueInputFieldNamesRule.mjs\"; // TODO: Spec Section\n\nimport { MaxIntrospectionDepthRule } from \"./rules/MaxIntrospectionDepthRule.mjs\"; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from \"./rules/LoneSchemaDefinitionRule.mjs\";\nimport { UniqueOperationTypesRule } from \"./rules/UniqueOperationTypesRule.mjs\";\nimport { UniqueTypeNamesRule } from \"./rules/UniqueTypeNamesRule.mjs\";\nimport { UniqueEnumValueNamesRule } from \"./rules/UniqueEnumValueNamesRule.mjs\";\nimport { UniqueFieldDefinitionNamesRule } from \"./rules/UniqueFieldDefinitionNamesRule.mjs\";\nimport { UniqueDirectiveNamesRule } from \"./rules/UniqueDirectiveNamesRule.mjs\";\nimport { PossibleTypeExtensionsRule } from \"./rules/PossibleTypeExtensionsRule.mjs\";\n/**\n * Technically these aren't part of the spec but they are strongly encouraged\n * validation rules.\n */\n\nexport var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\n\nexport var specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule].concat(recommendedRules));\n/**\n * @internal\n */\n\nexport var specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nvar MAX_LISTS_DEPTH = 3;\nexport function MaxIntrospectionDepthRule(context) {\n  /**\n   * Counts the depth of list fields in \"__Type\" recursively and\n   * returns `true` if the limit has been reached.\n   */\n  function checkDepth(node) {\n    var visitedFragments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object.create(null);\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (node.kind === Kind.FRAGMENT_SPREAD) {\n      var _fragmentName = node.name.value;\n\n      if (visitedFragments[_fragmentName] === true) {\n        // Fragment cycles are handled by `NoFragmentCyclesRule`.\n        return false;\n      }\n\n      var fragment = context.getFragment(_fragmentName);\n\n      if (!fragment) {\n        // Missing fragments checks are handled by `KnownFragmentNamesRule`.\n        return false;\n      } // Rather than following an immutable programming pattern which has\n      // significant memory and garbage collection overhead, we've opted to\n      // take a mutable approach for efficiency's sake. Importantly visiting a\n      // fragment twice is fine, so long as you don't do one visit inside the\n      // other.\n\n\n      try {\n        visitedFragments[_fragmentName] = true;\n        return checkDepth(fragment, visitedFragments, depth);\n      } finally {\n        visitedFragments[_fragmentName] = null;\n      }\n    }\n\n    if (node.kind === Kind.FIELD && ( // check all introspection lists\n    node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {\n      // $FlowFixMe[reassign-const] why are argument parameters treated as const in flow?\n      depth++; // eslint-disable-line no-param-reassign\n\n      if (depth >= MAX_LISTS_DEPTH) {\n        return true;\n      }\n    } // handles fields and inline fragments\n\n\n    if ('selectionSet' in node && node.selectionSet) {\n      for (var _i2 = 0, _node$selectionSet$se2 = node.selectionSet.selections; _i2 < _node$selectionSet$se2.length; _i2++) {\n        var child = _node$selectionSet$se2[_i2];\n\n        if (checkDepth(child, visitedFragments, depth)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    Field: function Field(node) {\n      if (node.name.value === '__schema' || node.name.value === '__type') {\n        if (checkDepth(node)) {\n          context.reportError(new GraphQLError('Maximum introspection depth exceeded', [node]));\n          return false;\n        }\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\nexport function UniqueOperationNamesRule(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new GraphQLError(\"There can be only one operation named \\\"\".concat(operationName.value, \"\\\".\"), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\nexport function LoneAnonymousOperationRule(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new GraphQLError('This anonymous operation must be the only defined operation.', node));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new GraphQLError(node.name ? \"Subscription \\\"\".concat(node.name.value, \"\\\" must select only one top level field.\") : 'Anonymous Subscription must select only one top level field.', node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          var typeStr = print(typeCondition);\n          context.reportError(new GraphQLError(\"Fragment cannot condition on non composite type \\\"\".concat(typeStr, \"\\\".\"), typeCondition));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        var typeStr = print(node.typeCondition);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(node.name.value, \"\\\" cannot condition on non composite type \\\"\").concat(typeStr, \"\\\".\"), node.typeCondition));\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { print } from \"../../language/printer.mjs\";\nimport { isInputType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = typeFromAST(context.getSchema(), node.type);\n\n      if (type && !isInputType(type)) {\n        var variableName = node.variable.name.value;\n        var typeName = print(node.type);\n        context.reportError(new GraphQLError(\"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\"), node.type));\n      }\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { getNamedType, isLeafType } from \"../../type/definition.mjs\";\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            var fieldName = node.name.value;\n            var typeStr = inspect(type);\n            context.reportError(new GraphQLError(\"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since type \\\"\").concat(typeStr, \"\\\" has no subfields.\"), selectionSet));\n          }\n        } else if (!selectionSet) {\n          var _fieldName = node.name.value;\n\n          var _typeStr = inspect(type);\n\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(_fieldName, \"\\\" of type \\\"\").concat(_typeStr, \"\\\" must have a selection of subfields. Did you mean \\\"\").concat(_fieldName, \" { ... }\\\"?\"), node));\n        }\n      }\n    }\n  };\n}\n","import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\nexport function UniqueFragmentNamesRule(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new GraphQLError(\"There can be only one fragment named \\\"\".concat(fragmentName, \"\\\".\"), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n","import inspect from \"../../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isCompositeType } from \"../../type/definition.mjs\";\nimport { typeFromAST } from \"../../utilities/typeFromAST.mjs\";\nimport { doTypesOverlap } from \"../../utilities/typeComparators.mjs\";\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment cannot be spread here as objects of type \\\"\".concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        var parentTypeStr = inspect(parentType);\n        var fragTypeStr = inspect(fragType);\n        context.reportError(new GraphQLError(\"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of type \\\"\").concat(parentTypeStr, \"\\\" can never be of type \\\"\").concat(fragTypeStr, \"\\\".\"), node));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {\n      var spreadNode = spreadNodes[_i2];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var viaPath = cyclePath.slice(0, -1).map(function (s) {\n          return '\"' + s.name.value + '\"';\n        }).join(', ');\n        context.reportError(new GraphQLError(\"Cannot spread fragment \\\"\".concat(spreadName, \"\\\" within itself\") + (viaPath !== '' ? \" via \".concat(viaPath, \".\") : '.'), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new GraphQLError(\"There can be only one variable named \\\"$\".concat(variableName, \"\\\".\"), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\nexport function NoUndefinedVariablesRule(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          var varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\"), [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n","import { GraphQLError } from \"../../error/GraphQLError.mjs\";\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\nexport function NoUnusedVariablesRule(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n\n        for (var _i2 = 0; _i2 < usages.length; _i2++) {\n          var _ref2 = usages[_i2];\n          var node = _ref2.node;\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {\n          var variableDef = _variableDefs2[_i4];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? \"Variable \\\"$\".concat(variableName, \"\\\" is never used in operation \\\"\").concat(operation.name.value, \"\\\".\") : \"Variable \\\"$\".concat(variableName, \"\\\" is never used.\"), variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n","function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nimport { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport var ASTValidationContext = /*#__PURE__*/function () {\n  function ASTValidationContext(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._onError(error);\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  _proto.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {\n          var selection = _set$selections2[_i2];\n\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n\n        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {\n          var spread = _this$getFragmentSpre2[_i4];\n          var fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  return ASTValidationContext;\n}();\nexport var SDLValidationContext = /*#__PURE__*/function (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema, onError) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast, onError) || this;\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\nexport var ValidationContext = /*#__PURE__*/function (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo, onError) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {\n        var frag = _this$getRecursivelyR2[_i6];\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  _proto3.getEnumValue = function getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n","import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n","import invariant from \"../../../jsutils/invariant.mjs\";\nimport { GraphQLError } from \"../../../error/GraphQLError.mjs\";\nimport { getNamedType, isInputObjectType } from \"../../../type/definition.mjs\";\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field: function Field(node) {\n      var fieldDef = context.getFieldDef();\n      var deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        var parentType = context.getParentType();\n        parentType != null || invariant(0);\n        context.reportError(new GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated. \").concat(deprecationReason), node));\n      }\n    },\n    Argument: function Argument(node) {\n      var argDef = context.getArgument();\n      var deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        var directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(new GraphQLError(\"Directive \\\"@\".concat(directiveDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n        } else {\n          var parentType = context.getParentType();\n          var fieldDef = context.getFieldDef();\n          parentType != null && fieldDef != null || invariant(0);\n          context.reportError(new GraphQLError(\"Field \\\"\".concat(parentType.name, \".\").concat(fieldDef.name, \"\\\" argument \\\"\").concat(argDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        var inputFieldDef = inputObjectDef.getFields()[node.name.value]; // flowlint-next-line unnecessary-optional-chain:off\n\n        var deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(new GraphQLError(\"The input field \".concat(inputObjectDef.name, \".\").concat(inputFieldDef.name, \" is deprecated. \").concat(deprecationReason), node));\n        }\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var enumValueDef = context.getEnumValue();\n      var deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        var enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(0);\n        context.reportError(new GraphQLError(\"The enum value \\\"\".concat(enumTypeDef.name, \".\").concat(enumValueDef.name, \"\\\" is deprecated. \").concat(deprecationReason), node));\n      }\n    }\n  };\n}\n","import { specifiedRules, validate, NoUnusedFragmentsRule, KnownFragmentNamesRule, Kind, ExecutableDefinitionsRule, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, } from 'graphql';\nconst specifiedSDLRules = [\n    LoneSchemaDefinitionRule,\n    UniqueOperationTypesRule,\n    UniqueTypeNamesRule,\n    UniqueEnumValueNamesRule,\n    UniqueFieldDefinitionNamesRule,\n    UniqueDirectiveNamesRule,\n    KnownTypeNamesRule,\n    KnownDirectivesRule,\n    UniqueDirectivesPerLocationRule,\n    PossibleTypeExtensionsRule,\n    UniqueArgumentNamesRule,\n    UniqueInputFieldNamesRule,\n];\nexport function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n    const rules = specifiedRules.filter(rule => {\n        if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n            return false;\n        }\n        if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n            return false;\n        }\n        return true;\n    });\n    if (customRules) {\n        Array.prototype.push.apply(rules, customRules);\n    }\n    if (isSchemaDocument) {\n        Array.prototype.push.apply(rules, specifiedSDLRules);\n    }\n    const errors = validate(schema, ast, rules);\n    return errors.filter(error => {\n        if (error.message.includes('Unknown directive') && error.nodes) {\n            const node = error.nodes[0];\n            if (node && node.kind === Kind.DIRECTIVE) {\n                const name = node.name.value;\n                if (name === 'arguments' || name === 'argumentDefinitions') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    });\n}\n//# sourceMappingURL=validateWithCustomRules.js.map","import { GraphQLError, print, validate, NoDeprecatedCustomRule, parse, } from 'graphql';\nimport { CharacterStream, onlineParser } from '../parser';\nimport { Range, validateWithCustomRules, Position } from '../utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    var _a, _b;\n    let ast = null;\n    let fragments = '';\n    if (externalFragments) {\n        fragments =\n            typeof externalFragments === 'string'\n                ? externalFragments\n                : externalFragments.reduce((acc, node) => acc + print(node) + '\\n\\n', '');\n    }\n    const enhancedQuery = fragments ? `${query}\\n\\n${fragments}` : query;\n    try {\n        ast = parse(enhancedQuery);\n    }\n    catch (error) {\n        if (error instanceof GraphQLError) {\n            const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, enhancedQuery);\n            return [\n                {\n                    severity: DIAGNOSTIC_SEVERITY.Error,\n                    message: error.message,\n                    source: 'GraphQL: Syntax',\n                    range,\n                },\n            ];\n        }\n        throw error;\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = validateWithCustomRules(schema, ast, customRules, isRelayCompatMode).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = validate(schema, ast, [\n        NoDeprecatedCustomRule,\n    ]).flatMap(error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    for (const [i, node] of error.nodes.entries()) {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[i];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    }\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map","import CodeMirror from 'codemirror';\nimport { getDiagnostics } from 'graphql-language-service';\nconst SEVERITY = ['error', 'warning', 'information', 'hint'];\nconst TYPE = {\n    'GraphQL: Validation': 'validation',\n    'GraphQL: Deprecation': 'deprecation',\n    'GraphQL: Syntax': 'syntax',\n};\nCodeMirror.registerHelper('lint', 'graphql', (text, options) => {\n    const { schema, validationRules, externalFragments } = options;\n    const rawResults = getDiagnostics(text, schema, validationRules, undefined, externalFragments);\n    const results = rawResults.map(error => ({\n        message: error.message,\n        severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n        type: error.source ? TYPE[error.source] : undefined,\n        from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n        to: CodeMirror.Pos(error.range.end.line, error.range.end.character),\n    }));\n    return results;\n});\n//# sourceMappingURL=lint.js.map"],"names":["Range","constructor","start","end","this","containsPosition","position","line","character","setStart","Position","setEnd","__name","lessThanOrEqualTo","setLine","setCharacter","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","UniqueOperationTypesRule","schema","definedOperationTypes","Object","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","operationTypesNodes","operationTypes","_i2","length","operationType","operation","alreadyDefinedOperationType","concat","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","value","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","OPERATION_DEFINITION","FRAGMENT_DEFINITION","isTypeSystemDefinitionNode","SCHEMA_DEFINITION","isTypeDefinitionNode","DIRECTIVE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","isTypeSystemExtensionNode","SCHEMA_EXTENSION","isTypeExtensionNode","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","KnownTypeNamesRule","existingTypesMap","definedTypes","_context$getDocument$2","getDocument","definitions","def","typeNames","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","Array","isArray","standardTypeNames","indexOf","isStandardTypeName","suggestedTypes","suggestionList","didYouMean","specifiedScalarTypes","introspectionTypes","map","_defKindToExtKind","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","astDefinitions","_i4","Directive","_key","_parent","_path","candidateLocation","appliedTo","invariant","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","inspect","getDirectiveLocationForOperation","FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION","SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE_DEFINITION","ENUM_VALUE","INPUT_OBJECT","INPUT_VALUE_DEFINITION","INPUT_FIELD_DEFINITION","ARGUMENT_DEFINITION","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","_i6","_node$directives2","_directive","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","UniqueArgumentNamesRule","knownArgNames","Field","Argument","argName","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","push","leave","pop","ObjectField","ExecutableDefinitionsRule","Document","_node$definitions2","definition","defName","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","_context$getRecursive2","getRecursivelyReferencedFragments","fragmentDef","fragName","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread","target","i","arguments","source","forEach","getOwnPropertyDescriptors","defineProperties","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","arg","_def$arguments","argsNodes","directiveNode","knownArgs","_directiveNode$argume2","argNode","suggestions","isValidValueNode","locationType","getInputType","getNamedType","isLeafType","parseLiteral","_typeStr","print","error","_typeStr2","message","typeStr","ProvidedRequiredArgumentsOnDirectivesRule","requiredArgsMap","keyMap","isRequiredArgument","argNodes","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","_argNodes","argNodeMap","_i8","_Object$keys2","argType","argTypeStr","isType","NON_NULL_TYPE","defaultValue","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","isNonNullType","NULL","nullableLocationType","ofType","isTypeSubTypeOf","reasonMessage","reason","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","_getReferencedFieldsA","getReferencedFieldsAndFragmentNames","fieldMap2","fragmentNames2","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","_getReferencedFieldsA2","fieldMap1","fragmentNames1","_getReferencedFieldsA3","j","parentFieldsAreMutuallyExclusive","_i7","fields2","fields1","conflict","findConflict","field1","field2","parentType1","node1","def1","parentType2","node2","def2","_node1$arguments","_node2$arguments","name1","name2","arguments1","arguments2","every","argument1","value1","value2","argument2","find","argument","sameArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","_getFieldsAndFragment2","getFieldsAndFragmentNames","_getFieldsAndFragment3","_i3","_j","findConflictsBetweenSubSelectionSets","_ref6","reduce","allFields","_ref7","_ref8","subfieldConflicts","isListType","parentType","cached","get","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","set","fragmentType","typeFromAST","typeCondition","_i9","_selectionSet$selecti2","selections","selection","alias","inlineFragmentType","PairSet","_data","_proto","prototype","a","b","first","result","_pairSetAdd","recommendedRules","freeze","checkDepth","visitedFragments","depth","_fragmentName","_node$selectionSet$se2","specifiedRules","knownOperationNames","operationName","operationCount","slice","InlineFragment","isCompositeType","VariableDefinition","isInputType","variableName","variable","_fieldName","getParentType","getFieldDef","suggestion","isAbstractType","Set","usageCount","_schema$getPossibleTy2","getPossibleTypes","possibleType","_possibleType$getInte2","getInterfaces","_usageCount$possibleI","possibleInterface","arrayFrom","sort","typeA","typeB","usageCountDiff","isSubType","naturalCompare","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","s","knownVariableNames","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","_variableDefs2","variableDef","argDef","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","_objectValues2","objectValues","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","fieldNode","_fieldNode$arguments","_fieldDef$args2","varDefMap","varDef","varTypeStr","Map","SelectionSet","_getFieldsAndFragment","_i5","_objectEntries2","objectEntries","_ref5","collectConflictsWithin","findConflictsWithinSelectionSet","_ref3","_ref2$","reasonMsg","_inheritsLoose","subClass","superClass","__proto__","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","fragments","frags","statement","spreads","setsToVisit","_set$selections2","collectedNames","nodesToVisit","_this$getFragmentSpre2","ValidationContext","_ASTValidationContext2","typeInfo","_this2","call","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","_proto3","getVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","_this$getRecursivelyR2","getEnumValue","validate","documentAST","rules","options","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","e","NoDeprecatedCustomRule","deprecationReason","directiveDef","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","includes","nodes","DIRECTIVE","SEVERITY$1","DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","externalFragments","_a","_b","acc","enhancedQuery","parse","range","getRange","column","severity","validateQuery","validationErrorAnnotations","flatMap","annotations","deprecationWarningAnnotations","Warning","highlightedNodes","entries","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","CharacterStream","eol","token","getStartOfToken","getCurrentPosition","SEVERITY","TYPE","CodeMirror","registerHelper","text","validationRules","from","Pos","to"],"sourceRoot":""}